import React from 'react';
import ReactDOM from 'react-dom';

Компонент
export default class Hello extends React.Component {
  render() {
    return <div>Hello</div>;
  }
}

Очевидные тезисы
Компонент React – это класс, который наследуется от класса React.Component (как мы увидим позже, это не единственный способ создать компонент).
Функция render возвращает нечто (рассмотрим позже), что будет отрисовано в браузере. Класс-компонент без функции render существовать не может, это его интерфейс.

JSX – это похожее на XML-разметку расширение для JavaScript, созданное специально для задач React. React из коробки поставляется с набором компонентов, которые полностью повторяют HTML. По большей части синтаксис и структура JSX и HTML совпадают, но есть некоторые важные различия:

Так как это похожий на XML синтаксис, одиночные теги в JSX должны быть закрыты: <hr />.
Вместо атрибута class в JSX используется имя свойства в DOM: className.

Так же как и в HTML, из компонентов можно строить композиции, например такую:
const vdom = (
  <div className="card">
    <div className="card-body">
      <h4 className="card-title">Card title</h4>
      <p className="card-text">my text</p>
      <a href="#" className="btn btn-primary">Go somewhere</a>
    </div>
  </div>
);



Любой текст, записанный внутри тегов (будем называть их так для простоты), остаётся просто статическим текстом на выводе. А что делать, если нужно вставить значение переменной? Ответ ниже:

const name = 'Eva';
const cname = 'container';

const vdom1 = <div>Hello, {name}</div>;
const vdom2 = <div>Hello, {name.repeat(3)}</div>;
const vdom3 = <div className={cname}>Hello!</div>;



Для решения этой задачи, в React ввели специальный компонент <React.Fragment>, которым можно оборачивать любую коллекцию элементов. Его особенность в том, что этот элемент никак не отражается в реальном DOM, а существует только на уровне JSX.

class Section extends React.Component {
  render() {
    const { header, body } = this.props;

    return (
      <React.Fragment>
        <h2>{header}</h2>
        <div>{body}</div>
      </React.Fragment>
    );
  }
}

У этого элемента есть короткая версия <> записи:

class Section extends React.Component {
  render() {
    const { header, body } = this.props;

    return (
      <>
        <h2>{header}</h2>
        <div>{body}</div>
      </>
    );
  }
}


Для решения этой задачи создатели React рекомендуют использовать пакет classnames. Принцип его работы прост: вместо манипулирования строчкой напрямую, нужно сформировать правильный объект, который уже будет преобразован в строку.

import cn from 'classnames';

class Button extends React.Component {
  render () {
    const { isPressed, isHovered, label } = this.props;
    // значение это true или false. Если значение true, то класс будет включен, если false – то нет
    // 'btn' это класс который будет подставлен в любом случае
    const btnClass = cn('btn', {
      'btn-pressed': isPressed,
      'btn-over': !isPressed && isHovered,
    });
    return <button className={btnClass}>{label}</button>;
  }
};



Массивы
Массив: добавление
Самое простое, это добавление в массив:

const items = ['one', 'two', 'three'];
const item = 'four';
const newItems = [...items, item];
// ['one', 'two', 'three', 'four'];
Если необходимо добавить элемент в начало, то нужно всего лишь поменять местами элементы массива:

const newItems = [item, ...items];
// ['four', 'one', 'two', 'three'];


Использование immutability-helper
import update from 'immutability-helper';

const state1 = ['x'];
const state2 = update(state1, { $push: ['y'] }); // ['x', 'y']



Объекты
Объект: добавление
Так же просто, как и с массивом.

const items = { a: 1, b: 2 };
const newItems = { ...items, c: 3 };
// { a: 1, b: 2, c: 3 }
Либо, если ключ вычисляется динамически, нужно делать так:

const items = { a: 1, b: 2 };
const key = 'c';
const newItems = { ...items, [key]: 3 };
// { a: 1, b: 2, c: 3 }


Объект: изменение
Абсолютно то же самое, что и добавление.

const items = { a: 1, b: 2 };
const newItems = { ...items, a: 3 };
// { a: 3, b: 2 }
Использование immutability-helper
const data = { a: 1, b: 2 };
const key = 'a';
const newData = update(data, { [key]: { $set: 3 } });
// { a: 3, b: 2 }


Virtual DOM
В реальности после того, как отработает их рендеринг (вызов функции render для всего дерева компонентов), создаётся так называемый виртуальный DOM (virtual DOM).
Это просто JS-объект определённой структуры, который отражает состояние экрана.
Далее React сравнивает новое дерево виртуального DOM со старым и строит разницу между ними ("дифф", или объект, описывающий разницу между старым и новым состоянием).
И только в этот момент начинается отрисовка нового состояния в реальный DOM.
Здесь уже должно быть понятно, что React умнее, чем кажется на первый взгляд, и вносит изменения в реальный DOM настолько эффективно, насколько это возможно, ведь он знает КАК его надо изменить.
